// Theme Management with Cookie Storage
(function(){
    // Cookie helper functions
    function setCookie(name, value, days) {
        const expires = new Date();
        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
        document.cookie = name + '=' + value + ';expires=' + expires.toUTCString() + ';path=/';
    }

    function getCookie(name) {
        const nameEQ = name + '=';
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    // Detect system preference
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const savedTheme = getCookie('theme');
    
    // Apply theme: priority = saved cookie > system preference > default (dark)
    if (savedTheme === 'light' || (!savedTheme && !prefersDark)) {
        document.body.classList.add('light-mode');
    }

    // Update theme icon based on current mode
    function updateThemeIcon() {
        const themeIcon = document.querySelector('.theme-icon');
        if (themeIcon) {
            // Usa √≠cone de meio-dia/meia-noite ao inv√©s de sol/lua
            themeIcon.textContent = document.body.classList.contains('light-mode') ? 'üí°' : 'ÔøΩ';
        }
    }

    // Initial icon update
    updateThemeIcon();

    // Theme toggle button handler
    document.addEventListener('DOMContentLoaded', function() {
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', function() {
                document.body.classList.toggle('light-mode');
                const isLight = document.body.classList.contains('light-mode');
                setCookie('theme', isLight ? 'light' : 'dark', 365);
                updateThemeIcon();
            });
        }
    });
})();

// Animated Stats Counter
(function(){
    function animateCounter(element, target, duration = 2000) {
        const start = 0;
        const increment = target / (duration / 16);
        let current = start;
        
        const timer = setInterval(() => {
            current += increment;
            if (current >= target) {
                element.textContent = target.toLocaleString('pt-BR');
                clearInterval(timer);
            } else {
                element.textContent = Math.floor(current).toLocaleString('pt-BR');
            }
        }, 16);
    }

    document.addEventListener('DOMContentLoaded', function() {
        const statNumbers = document.querySelectorAll('.stat-number');
        
        // Start animation after a brief delay
        setTimeout(() => {
            statNumbers.forEach(stat => {
                const target = parseInt(stat.getAttribute('data-target'));
                animateCounter(stat, target);
            });
        }, 300);
    });
})();

// FAQ Accordion
(function(){
    document.addEventListener('DOMContentLoaded', function() {
        const faqItems = document.querySelectorAll('.faq-item');
        
        faqItems.forEach(item => {
            const question = item.querySelector('.faq-question');
            
            question.addEventListener('click', () => {
                // Close other items
                faqItems.forEach(otherItem => {
                    if (otherItem !== item && otherItem.classList.contains('active')) {
                        otherItem.classList.remove('active');
                    }
                });
                
                // Toggle current item
                item.classList.toggle('active');
            });
        });
    });
})();

// Scroll Reveal Animation
(function(){
    function revealOnScroll() {
        const reveals = document.querySelectorAll('.scroll-reveal');
        
        reveals.forEach(element => {
            const windowHeight = window.innerHeight;
            const elementTop = element.getBoundingClientRect().top;
            const revealPoint = 100;
            
            if (elementTop < windowHeight - revealPoint) {
                element.classList.add('revealed');
            }
        });
    }
    
    window.addEventListener('scroll', revealOnScroll);
    document.addEventListener('DOMContentLoaded', revealOnScroll);
})();

// Bot√£o Voltar ao Topo
(function(){
    document.addEventListener('DOMContentLoaded', function() {
        const backToTop = document.getElementById('backToTop');
        
        if (backToTop) {
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    backToTop.classList.add('visible');
                } else {
                    backToTop.classList.remove('visible');
                }
            });
            
            backToTop.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }
    });
})();

// Sistema de Notifica√ß√µes
(function(){
    window.NotificationSystem = {
        container: null,
        
        init: function() {
            this.container = document.getElementById('notificationContainer');
        },
        
        show: function(title, message, type = 'info', duration = 5000) {
            if (!this.container) this.init();
            
            const icons = {
                info: 'üí¨',
                warning: '‚ö†Ô∏è',
                danger: 'üö®',
                success: '‚úÖ'
            };
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div class="notification-icon">${icons[type] || icons.info}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">√ó</button>
            `;
            
            this.container.appendChild(notification);
            
            // Close button
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.addEventListener('click', () => {
                this.close(notification);
            });
            
            // Auto-close
            if (duration > 0) {
                setTimeout(() => {
                    this.close(notification);
                }, duration);
            }
            
            return notification;
        },
        
        close: function(notification) {
            notification.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
        window.NotificationSystem.init();
    });
})();

// Timeline de Alertas
(function(){
    const alertHistory = [
        {
            time: '2h atr√°s',
            title: 'Alerta de Chuva Forte',
            message: 'Chuva intensa detectada na Zona Norte. Sensores registraram 45mm/h.',
            type: 'warning',
            badge: 'Resolvido'
        },
        {
            time: '5h atr√°s',
            title: 'Teste do Sistema',
            message: 'Teste mensal realizado com sucesso. Todas as sirenes operacionais.',
            type: 'info',
            badge: 'Conclu√≠do'
        },
        {
            time: '1 dia atr√°s',
            title: 'N√≠vel do Rio em Aten√ß√£o',
            message: 'Rio alcan√ßou 4.2m na Zona Leste. Popula√ß√£o alertada para monitoramento.',
            type: 'warning',
            badge: 'Normalizado'
        },
        {
            time: '3 dias atr√°s',
            title: 'Ventos Fortes',
            message: 'Rajadas de at√© 65km/h registradas. Alerta emitido para √°reas abertas.',
            type: 'danger',
            badge: 'Resolvido'
        },
        {
            time: '1 semana atr√°s',
            title: 'Treinamento Comunit√°rio',
            message: 'Simulado de evacua√ß√£o realizado com 200 moradores. Tempo: 12min.',
            type: 'info',
            badge: 'Sucesso'
        }
    ];
    
    document.addEventListener('DOMContentLoaded', function() {
        const timeline = document.getElementById('alertTimeline');
        if (!timeline) return;
        
        alertHistory.forEach(alert => {
            const item = document.createElement('div');
            item.className = `timeline-item ${alert.type}`;
            
            const icons = {
                info: 'üí¨',
                warning: '‚ö†Ô∏è',
                danger: 'üö®',
                success: '‚úÖ'
            };
            
            item.innerHTML = `
                <div class="timeline-icon">${icons[alert.type]}</div>
                <div class="timeline-content">
                    <div class="timeline-time">${alert.time}</div>
                    <div class="timeline-title">${alert.title}</div>
                    <div class="timeline-message">${alert.message}</div>
                    <span class="timeline-badge ${alert.type}">${alert.badge}</span>
                </div>
            `;
            
            timeline.appendChild(item);
        });
    });
})();

// Basic demo script: sensors and WebAudio siren simulation
(function(){
    const sensorsEl = document.getElementById('sensors');
    
    // Global sensor data with realistic parameters
    window.sensorData = [
        {id:'S-01', name:'Pluvi√¥metro - Zona Norte', type:'rain', value:12, unit:'mm/h', normalRange:[0,20], warnRange:[20,40], min:0, max:100},
        {id:'S-02', name:'N√≠vel do Rio - Zona Leste', type:'river', value:3.8, unit:'m', normalRange:[1,3.5], warnRange:[3.5,4.5], min:1, max:6},
        {id:'S-03', name:'Anem√¥metro - Zona Sul', type:'wind', value:8, unit:'km/h', normalRange:[0,30], warnRange:[30,60], min:0, max:120},
        {id:'S-04', name:'Esta√ß√£o Meteo - Centro', type:'weather', value:'Normal', unit:'', normalRange:[0,1], warnRange:[1,2], min:0, max:3}
    ];

    // Configuration: limiares de criticidade (ajust√°veis)
    const thresholds = {
        rain: { warn: 35, danger: 75 },   // mm/h
        river: { warn: 4.0, danger: 5.0 }, // meters
        wind: { warn: 40, danger: 60 }    // km/h
    };

    // expose for other modules / dev console
    window.thresholds = thresholds;

    // Hist√≥rico de amostras para os gr√°ficos (exposto globalmente)
    window.sensorHistory = { timestamps: [], rain: [], wind: [], river: [], maxLen: 60 };

    function getSensorLevel(sensor){
        if(sensor.type === 'weather') return sensor.value === 'Normal' ? '' : (sensor.value === 'Aten√ß√£o' ? 'warn' : 'danger');
        const val = sensor.value;
        // Use configured thresholds when available
        if(sensor.type === 'rain'){
            if(val >= thresholds.rain.danger) return 'danger';
            if(val >= thresholds.rain.warn) return 'warn';
            return '';
        }
        if(sensor.type === 'river'){
            if(val >= thresholds.river.danger) return 'danger';
            if(val >= thresholds.river.warn) return 'warn';
            return '';
        }
        if(sensor.type === 'wind'){
            if(val >= thresholds.wind.danger) return 'danger';
            if(val >= thresholds.wind.warn) return 'warn';
            return '';
        }
        // fallback to original logic
        if(val >= sensor.warnRange[1] || val >= 5) return 'danger';
        if(val >= sensor.warnRange[0]) return 'warn';
        return '';
    }

    function getSensorDisplay(sensor){
        if(sensor.type === 'weather') return sensor.value;
        const level = getSensorLevel(sensor);
        if(level === 'danger') return 'Perigo';
        if(level === 'warn') return 'Aten√ß√£o';
        return 'Normal';
    }

    function renderSensors(){
        sensorsEl.innerHTML = '';
        window.sensorData.forEach(s=>{
            const div = document.createElement('div');
            div.className = 'sensor';
            const level = getSensorLevel(s);
            const display = getSensorDisplay(s);
            const valueText = s.type === 'weather' ? s.value : (s.value.toFixed(1) + ' ' + s.unit);
            div.innerHTML = '<div><strong>'+s.name+'</strong><div class="muted" style="font-size:12px;margin-top:6px">'+valueText+'</div></div><div style="text-align:right"><div class="dot '+(level)+'" aria-hidden="true"></div></div>';
            sensorsEl.appendChild(div);
        });
    }

    renderSensors();

    // Expose functions globally for dev panel
    window.updateSensors = renderSensors;
    window.getSensors = () => window.sensorData;

    document.getElementById('refresh').addEventListener('click', ()=> {
        // Realistic random variation
        window.sensorData[0].value = Math.max(0, Math.min(100, window.sensorData[0].value + (Math.random() - 0.5) * 10));
        window.sensorData[2].value = Math.max(0, Math.min(120, window.sensorData[2].value + (Math.random() - 0.5) * 15));
        renderSensors();
    });

    // WebAudio siren
    let audioCtx, oscillator, gainNode, sirenInterval;
    // Secondary alarm (beep pattern) used when multiple sensors are critical
    let secondaryOsc, secondaryGain, secondaryInterval;

    function startSiren(){
        if(audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // expose to global so other modules can check state reliably
        window.audioCtx = audioCtx;

        oscillator = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.0001, audioCtx.currentTime);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();

        // fade in
        gainNode.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.5);

        // sweep frequency to simulate siren
        let up = true;
        sirenInterval = setInterval(()=>{
            const now = audioCtx.currentTime;
            if(up){
                oscillator.frequency.linearRampToValueAtTime(1600, now + 0.9);
            } else {
                oscillator.frequency.linearRampToValueAtTime(400, now + 0.9);
            }
            up = !up;
        }, 900);
        
        // Update siren status
        const sirenStatus = document.getElementById('sirenStatus');
        if(sirenStatus){
            sirenStatus.textContent = 'Ativa';
            sirenStatus.className = 'dev-status danger';
        }
    }

    function stopSiren(){
        if(!audioCtx) return;
        clearInterval(sirenInterval);
        if(gainNode && audioCtx){
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
        }
        setTimeout(()=>{
            try{
                if(oscillator) oscillator.stop();
                if(oscillator) oscillator.disconnect();
                if(gainNode) gainNode.disconnect();
                if(audioCtx) audioCtx.close();
            }catch(e){/* ignore */}
            audioCtx = oscillator = gainNode = null;
            // clear global marker
            window.audioCtx = null;
        }, 600);
        
        // Update siren status
        const sirenStatus = document.getElementById('sirenStatus');
        if(sirenStatus){
            sirenStatus.textContent = 'Desligada';
            sirenStatus.className = 'dev-status stopped';
        }
    }

    // Secondary alarm: short beeps (used when multiple sensors are critical)
    function startSecondaryAlarm(){
        if(secondaryOsc) return;
        // use a new small audio context if main siren not present, otherwise reuse audioCtx
        const ctx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        secondaryOsc = ctx.createOscillator();
        secondaryGain = ctx.createGain();
        secondaryOsc.type = 'square';
        secondaryOsc.frequency.setValueAtTime(1000, ctx.currentTime);
        secondaryGain.gain.setValueAtTime(0.0001, ctx.currentTime);
        secondaryOsc.connect(secondaryGain);
        secondaryGain.connect(ctx.destination);
        try{ secondaryOsc.start(); } catch(e){}

        // beep pattern every 800ms
        secondaryInterval = setInterval(()=>{
            try{
                secondaryGain.gain.cancelScheduledValues(ctx.currentTime);
                secondaryGain.gain.setValueAtTime(0.0001, ctx.currentTime);
                secondaryGain.gain.exponentialRampToValueAtTime(0.12, ctx.currentTime + 0.02);
                secondaryGain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.25);
            }catch(e){/* ignore */}
        }, 800);
        // expose marker
        window.secondaryAlarmActive = true;
    }

    function stopSecondaryAlarm(){
        if(!secondaryOsc) return;
        clearInterval(secondaryInterval);
        try{
            secondaryGain.gain.exponentialRampToValueAtTime(0.0001, (window.audioCtx || secondaryOsc.context).currentTime + 0.05);
        }catch(e){}
        setTimeout(()=>{
            try{ secondaryOsc.stop(); secondaryOsc.disconnect(); secondaryGain.disconnect(); }catch(e){}
            secondaryOsc = secondaryGain = null;
            window.secondaryAlarmActive = false;
        }, 120);
    }

    window.startSiren = startSiren;
    window.stopSiren = stopSiren;
    window.startSecondaryAlarm = startSecondaryAlarm;
    window.stopSecondaryAlarm = stopSecondaryAlarm;

    const demoBtn = document.getElementById('demoBtn');
    if(demoBtn){
        demoBtn.addEventListener('click', ()=>{
            startSiren();
            alert('Demonstra√ß√£o: alarme sonoro ativado. Em situa√ß√£o real, a sirene e mensagens autom√°ticas orientariam a popula√ß√£o.');
        });
    }
    
    const stopSirenBtn = document.getElementById('stopSiren');
    if(stopSirenBtn){
        stopSirenBtn.addEventListener('click', stopSiren);
    }

    // ensure stop on page unload
    window.addEventListener('beforeunload', stopSiren);
})();

// River Level Gauge: interactive visual representation
(function(){
    const riverLevel = document.getElementById('riverLevel');
    const riverValue = document.getElementById('riverValue');
    const lastUpdate = document.getElementById('lastUpdate');
    const changeRate = document.getElementById('changeRate');
    
    const increaseBtn = document.getElementById('increaseLevel');
    const decreaseBtn = document.getElementById('decreaseLevel');
    const resetBtn = document.getElementById('resetLevel');

    // Check if elements exist (graceful degradation)
    if(!riverLevel || !riverValue) return;

    let currentLevel = 3.8; // meters
    const minLevel = 1.0;
    const maxLevel = 6.0;

    function updateGauge(level){
        currentLevel = Math.max(minLevel, Math.min(maxLevel, level));
        
        // Calculate percentage (inverted: 0m at bottom, 6m at top)
        // Container height represents 0-6m, so percentage = level/6 * 100
        const percentage = (currentLevel / maxLevel) * 100;
        
        // Update visual height
        riverLevel.style.height = percentage + '%';
        riverValue.textContent = currentLevel.toFixed(1) + 'm';
        
        // Color coding based on risk
        let bgColor, riskText;
        if(currentLevel >= 5.0){
            bgColor = 'linear-gradient(180deg, rgba(255,95,87,0.7), rgba(255,95,87,0.9))';
            riskText = 'Perigo';
        } else if(currentLevel >= 4.0){
            bgColor = 'linear-gradient(180deg, rgba(255,184,107,0.6), rgba(255,184,107,0.8))';
            riskText = 'Aten√ß√£o';
        } else {
            bgColor = 'linear-gradient(180deg, rgba(6,180,214,0.6), rgba(6,140,214,0.8))';
            riskText = 'Normal';
        }
        riverLevel.style.background = bgColor;
        
        // Update info box
        const parent = riverLevel.closest('.card');
        if(parent){
            let infoBox = parent.querySelector('.risk-info');
            if(!infoBox){
                infoBox = parent.querySelector('[style*="border-left"]');
            }
            if(infoBox){
                const strong = infoBox.querySelector('strong');
                const p = infoBox.querySelector('p');
                if(currentLevel >= 5.0){
                    infoBox.style.background = 'rgba(255,95,87,0.08)';
                    infoBox.style.borderLeftColor = '#ff5f57';
                    if(strong){ strong.textContent = 'N√≠vel de Perigo'; strong.style.color = '#ff5f57'; }
                    if(p) p.textContent = 'Rio em n√≠vel cr√≠tico! Evacua√ß√£o imediata das √°reas de risco. Sirenes ativadas.';
                } else if(currentLevel >= 4.0){
                    infoBox.style.background = 'rgba(255,184,107,0.08)';
                    infoBox.style.borderLeftColor = '#ffb86b';
                    if(strong){ strong.textContent = 'N√≠vel de Aten√ß√£o'; strong.style.color = '#ffb86b'; }
                    if(p) p.textContent = 'Rio acima do limiar normal. Monitoramento refor√ßado ativo. Comunidades ribeirinhas foram notificadas.';
                } else {
                    infoBox.style.background = 'rgba(6,214,160,0.08)';
                    infoBox.style.borderLeftColor = '#06d6a0';
                    if(strong){ strong.textContent = 'N√≠vel Normal'; strong.style.color = '#06d6a0'; }
                    if(p) p.textContent = 'Rio dentro dos par√¢metros normais. Monitoramento de rotina mantido.';
                }
            }
        }
        
        // Update timestamp and rate
        if(lastUpdate) lastUpdate.textContent = 'Agora';
        if(changeRate){
            const rate = currentLevel >= 4.0 ? '+0.2 m/h' : currentLevel >= 3.0 ? '+0.1 m/h' : '0.0 m/h';
            changeRate.textContent = rate;
        }
    }

    // Event handlers
    if(increaseBtn) increaseBtn.addEventListener('click', ()=> updateGauge(currentLevel + 0.5));
    if(decreaseBtn) decreaseBtn.addEventListener('click', ()=> updateGauge(currentLevel - 0.5));
    if(resetBtn) resetBtn.addEventListener('click', ()=> updateGauge(3.8));

    // Initialize
    updateGauge(currentLevel);
    
    // Expose globally for dev panel and keep sensor synced
    window.updateRiverGauge = function(level){
        updateGauge(level);
        // Always sync with sensor 2
        if(window.sensorData && window.sensorData[1]){
            window.sensorData[1].value = level;
        }
    };
    window.getCurrentRiverLevel = () => currentLevel;
})();

// Developer Panel & Realistic Simulation Engine
(function(){
    // Wait for DOM to be fully loaded
    function initDevPanel(){
        const devPanel = document.getElementById('devPanel');
        const devToggle = document.getElementById('devToggle');
        
        console.log('Attempting to initialize Dev Panel...');
        console.log('devPanel element:', devPanel);
        console.log('devToggle element:', devToggle);
        
        if(!devPanel){
            console.error('devPanel element not found!');
            return;
        }
        
        if(!devToggle){
            console.error('devToggle element not found!');
            return;
        }
        
        console.log('Dev Panel elements found, attaching event listener...');
        
        // Toggle panel with immediate feedback
        devToggle.onclick = function(){
            console.log('Toggle button clicked!');
            console.log('Current classes:', devPanel.className);
            devPanel.classList.toggle('open');
            console.log('After toggle classes:', devPanel.className);
        };
        
        // Also try with addEventListener as backup
        devToggle.addEventListener('click', function(e){
            e.preventDefault();
            e.stopPropagation();
            console.log('Click event fired via addEventListener');
        });
        
        console.log('Event listener attached successfully');
        
        // Collapsible sections
        document.querySelectorAll('.dev-section h4').forEach(h4=>{
            h4.addEventListener('click', ()=> h4.parentElement.classList.toggle('collapsed'));
        });
        
        // Simulation State
        let simState = {
            active: true,
        speed: 1.0,
        time: 0,
        updateCount: 0,
        alertCount: 0,
        riverLevel: 3.8,
        riverRate: 0.2, // m/h
        autoUpdateInterval: 5000, // ms
        lastUpdate: Date.now()
    };
    
    let simTimer = null;
    let autoUpdateTimer = null;
    
    // Simulation Speed Control
    const simSpeed = document.getElementById('simSpeed');
    const simSpeedValue = document.getElementById('simSpeedValue');
    const simSpeedFill = document.getElementById('simSpeedFill');
    const simStatus = document.getElementById('simStatus');
    
    simSpeed.addEventListener('input', (e)=>{
        simState.speed = parseFloat(e.target.value);
        simSpeedValue.textContent = simState.speed.toFixed(1) + 'x';
        simSpeedFill.style.width = (simState.speed / 10 * 100) + '%';
        
        if(simState.speed === 0){
            pauseSimulation();
        } else if(!simState.active){
            startSimulation();
        }
    });
    
    // Simulation Controls
    document.getElementById('simPlay').addEventListener('click', startSimulation);
    document.getElementById('simPause').addEventListener('click', pauseSimulation);
    document.getElementById('simReset').addEventListener('click', resetSimulation);
    document.getElementById('simEmergency').addEventListener('click', triggerEmergency);
    
    function startSimulation(){
        simState.active = true;
        simStatus.textContent = 'Ativo';
        simStatus.className = 'dev-status active';
        
        if(!simTimer){
            simTimer = setInterval(runSimulationTick, 1000);
        }
        if(!autoUpdateTimer){
            autoUpdateTimer = setInterval(autoUpdateData, simState.autoUpdateInterval);
        }
        
        // Sistema de notifica√ß√µes aleat√≥rias
        if(!window.notificationTimer) {
            window.notificationTimer = setInterval(() => {
                const notifications = [
                    { title: 'Sensor Atualizado', message: 'Pluvi√¥metro Norte: leituras normais', type: 'info' },
                    { title: 'Sistema Online', message: 'Todos os sensores operacionais', type: 'success' },
                    { title: 'Monitoramento', message: 'N√≠vel do rio est√°vel em 3.8m', type: 'info' },
                    { title: 'Aten√ß√£o', message: 'Previs√£o de chuva para pr√≥ximas 2 horas', type: 'warning' },
                    { title: 'Teste Agendado', message: 'Pr√≥ximo teste em 5 dias', type: 'info' }
                ];
                
                // 20% de chance de mostrar notifica√ß√£o a cada check
                if (Math.random() < 0.2 && window.NotificationSystem) {
                    const notif = notifications[Math.floor(Math.random() * notifications.length)];
                    window.NotificationSystem.show(notif.title, notif.message, notif.type, 4000);
                }
            }, 15000); // Check a cada 15 segundos
        }
    }
    
    function pauseSimulation(){
        simState.active = false;
        simStatus.textContent = 'Pausado';
        simStatus.className = 'dev-status paused';
        
        if(simTimer){
            clearInterval(simTimer);
            simTimer = null;
        }
        if(autoUpdateTimer){
            clearInterval(autoUpdateTimer);
            autoUpdateTimer = null;
        }
        if(window.notificationTimer){
            clearInterval(window.notificationTimer);
            window.notificationTimer = null;
        }
    }
    
    function resetSimulation(){
        simState.time = 0;
        simState.updateCount = 0;
        simState.alertCount = 0;
        simState.riverLevel = 3.8;
        simState.riverRate = 0.2;
        
        // Reset sensors
        window.sensorData[0].value = 12;
        window.sensorData[1].value = 3.8;
        window.sensorData[2].value = 8;
        window.sensorData[3].value = 'Normal';
        
        window.updateSensors();
        window.updateRiverGauge(3.8);
        updateDevStats();
        
        alert('Simula√ß√£o resetada para valores iniciais.');
    }
    
    function triggerEmergency(){
        simState.riverLevel = 5.5;
        simState.riverRate = 0.8;
        
        window.sensorData[0].value = 85; // Heavy rain
        window.sensorData[1].value = 5.5;
        window.sensorData[2].value = 65; // Strong wind
        window.sensorData[3].value = 'Perigo';
        
        window.updateSensors();
        window.updateRiverGauge(5.5);
        window.startSiren();
        
        simState.alertCount++;
        updateDevStats();
        
        // Notifica√ß√£o de emerg√™ncia
        if(window.NotificationSystem) {
            window.NotificationSystem.show(
                'üö® ALERTA DE EMERG√äNCIA',
                'Todos os sensores em estado cr√≠tico! Sirenes ativadas. Siga para √°rea segura.',
                'danger',
                10000
            );
        }
        
        alert('üö® EMERG√äNCIA SIMULADA! Todos os sensores em estado cr√≠tico. Sirenes ativadas.');
    }
    
    // Realistic Simulation Tick
    function runSimulationTick(){
        if(!simState.active || simState.speed === 0) return;
        
        const deltaTime = simState.speed; // seconds per tick scaled by speed
        simState.time += deltaTime;
        
        // Update river level with rate (convert m/h to m/s)
        const riverDelta = (simState.riverRate / 3600) * deltaTime;
        simState.riverLevel = Math.max(1, Math.min(6, simState.riverLevel + riverDelta));
        
        // Natural river rate decay (tends toward equilibrium)
        if(Math.abs(simState.riverRate) > 0.05){
            simState.riverRate *= 0.995; // Slow decay
        }
        
        // Weather influence on river rate (realistic correlation)
        const rainLevel = window.sensorData[0].value;
        if(rainLevel > 40){
            simState.riverRate += 0.001 * deltaTime * (rainLevel / 20);
        } else if(rainLevel < 10 && simState.riverLevel > 2){
            simState.riverRate -= 0.0005 * deltaTime;
        }
        
        // Update sensor 2 (river) and gauge together - ALWAYS SYNCED
        window.sensorData[1].value = simState.riverLevel;
        window.updateRiverGauge(simState.riverLevel);
        
        // Realistic rain variation (follows patterns)
        const rainVariation = (Math.sin(simState.time / 30) * 5 + (Math.random() - 0.5) * 3) * deltaTime * 0.1;
        window.sensorData[0].value = Math.max(0, Math.min(100, window.sensorData[0].value + rainVariation));
        
        // Wind follows rain patterns (correlation)
        const windTarget = 10 + (window.sensorData[0].value / 100) * 40;
        window.sensorData[2].value += (windTarget - window.sensorData[2].value) * 0.05 * deltaTime;
        window.sensorData[2].value = Math.max(0, Math.min(120, window.sensorData[2].value));
        
        // Weather status follows river level
        if(simState.riverLevel >= 5){
            window.sensorData[3].value = 'Perigo';
        } else if(simState.riverLevel >= 4){
            window.sensorData[3].value = 'Aten√ß√£o';
        } else {
            window.sensorData[3].value = 'Normal';
        }
        
        // Auto-trigger siren in danger (with small hysteresis)
        try{
            const riverDanger = (window.thresholds && window.thresholds.river && window.thresholds.river.danger) || 5.0;
            const riverHyst = Math.max(0.3, (window.thresholds && window.thresholds.river && 0.5) || 0.5);
            if(simState.riverLevel >= riverDanger && !window.audioCtx){
                window.startSiren();
                simState.alertCount++;
            } else if(simState.riverLevel < (riverDanger - riverHyst) && window.audioCtx){
                window.stopSiren();
            }

            // Composite alarm: outros alertas s√≥ tocam se os tr√™s sensores estiverem cr√≠ticos
            const rain = window.sensorData[0] && Number(window.sensorData[0].value) || 0;
            const river = window.sensorData[1] && Number(window.sensorData[1].value) || 0;
            const wind = window.sensorData[2] && Number(window.sensorData[2].value) || 0;
            const rainCrit = (window.thresholds && window.thresholds.rain && window.thresholds.rain.danger) || 75;
            const windCrit = (window.thresholds && window.thresholds.wind && window.thresholds.wind.danger) || 60;
            const riverCrit = riverDanger;
            const allCritical = (rain >= rainCrit) && (river >= riverCrit) && (wind >= windCrit);
            if(allCritical){
                // Start secondary alarm (beeps) in addition to main siren
                window.startSecondaryAlarm();
                // ensure main siren on as well
                if(!window.audioCtx) { window.startSiren(); simState.alertCount++; }
            } else {
                window.stopSecondaryAlarm();
            }
        }catch(e){ /* ignore safety */ }
        
        updateDevStats();
    }
    
    // Auto-update data display
    function autoUpdateData(){
        if(!simState.active) return;
        
        window.updateSensors();
        // River gauge is already updated in runSimulationTick, no need to call again
        
        simState.updateCount++;
        simState.lastUpdate = Date.now();
        updateDevStats();
        // Update charts if available
        try{ if(typeof updateCharts === 'function') updateCharts(); }catch(e){}
    }
    
    // Update dev panel stats
    function updateDevStats(){
        const hours = Math.floor(simState.time / 3600);
        const minutes = Math.floor((simState.time % 3600) / 60);
        const seconds = Math.floor(simState.time % 60);
        
        document.getElementById('simTime').textContent = 
            String(hours).padStart(2,'0') + ':' + 
            String(minutes).padStart(2,'0') + ':' + 
            String(seconds).padStart(2,'0');
        
        document.getElementById('updateCount').textContent = simState.updateCount;
        document.getElementById('alertCount').textContent = simState.alertCount;
        document.getElementById('devRiverLevel').textContent = simState.riverLevel.toFixed(2) + 'm';
        document.getElementById('riverRateValue').textContent = (simState.riverRate >= 0 ? '+' : '') + simState.riverRate.toFixed(2) + ' m/h';
    }
    
    // River Level Manual Control
    const riverLevelSlider = document.getElementById('riverLevelSlider');
    const riverLevelFill = document.getElementById('riverLevelFill');
    
    riverLevelSlider.addEventListener('input', (e)=>{
        const level = parseFloat(e.target.value);
        simState.riverLevel = level;
        riverLevelFill.style.width = ((level - 1) / 5 * 100) + '%';
        
        // Update gauge and sensor together
        window.updateRiverGauge(level);
        window.sensorData[1].value = level;
        window.updateSensors();
        updateDevStats();
    });
    
    // River Rate Control
    const riverRate = document.getElementById('riverRate');
    const riverRateFill = document.getElementById('riverRateFill');
    
    riverRate.addEventListener('input', (e)=>{
        const rate = parseFloat(e.target.value);
        simState.riverRate = rate;
        riverRateFill.style.width = ((rate + 5) / 10 * 100) + '%';
        document.getElementById('riverRateValue').textContent = (rate >= 0 ? '+' : '') + rate.toFixed(1) + ' m/h';
    });
    
    // River preset buttons
    document.getElementById('riverNormal').addEventListener('click', ()=>{ riverLevelSlider.value = 3; riverLevelSlider.dispatchEvent(new Event('input')); });
    document.getElementById('riverWarning').addEventListener('click', ()=>{ riverLevelSlider.value = 4; riverLevelSlider.dispatchEvent(new Event('input')); });
    document.getElementById('riverDanger').addEventListener('click', ()=>{ riverLevelSlider.value = 5; riverLevelSlider.dispatchEvent(new Event('input')); });
    document.getElementById('riverCritical').addEventListener('click', ()=>{ riverLevelSlider.value = 6; riverLevelSlider.dispatchEvent(new Event('input')); });
    
    // Siren Controls
    document.getElementById('sirenTrigger').addEventListener('click', ()=>{ window.startSiren(); simState.alertCount++; updateDevStats(); });
    document.getElementById('sirenStop').addEventListener('click', window.stopSiren);
    document.getElementById('sirenTest').addEventListener('click', ()=>{ 
        window.startSiren(); 
        setTimeout(window.stopSiren, 3000); 
    });
    
    // Auto-update interval control
    const updateInterval = document.getElementById('updateInterval');
    const updateIntervalFill = document.getElementById('updateIntervalFill');
    const updateIntervalValue = document.getElementById('updateIntervalValue');
    const autoUpdateStatus = document.getElementById('autoUpdateStatus');
    
    updateInterval.addEventListener('input', (e)=>{
        const interval = parseInt(e.target.value) * 1000;
        simState.autoUpdateInterval = interval;
        updateIntervalFill.style.width = ((parseInt(e.target.value) - 1) / 29 * 100) + '%';
        updateIntervalValue.textContent = (interval / 1000) + 's';
        autoUpdateStatus.textContent = 'Ativo (' + (interval / 1000) + 's)';
        
        // Restart timer with new interval
        if(autoUpdateTimer){
            clearInterval(autoUpdateTimer);
            autoUpdateTimer = setInterval(autoUpdateData, interval);
        }
    });
    
    document.getElementById('forceRefresh').addEventListener('click', autoUpdateData);
    
    // Sensor manual control (global function)
    window.setSensorState = function(index, state){
        const sensor = window.sensorData[index];
        if(state === 'normal'){
            if(sensor.type === 'rain') sensor.value = 10;
            else if(sensor.type === 'river') sensor.value = 2.5;
            else if(sensor.type === 'wind') sensor.value = 15;
            else sensor.value = 'Normal';
        } else if(state === 'warn'){
            if(sensor.type === 'rain') sensor.value = 35;
            else if(sensor.type === 'river') sensor.value = 4.0;
            else if(sensor.type === 'wind') sensor.value = 50;
            else sensor.value = 'Aten√ß√£o';
        } else if(state === 'danger'){
            if(sensor.type === 'rain') sensor.value = 75;
            else if(sensor.type === 'river') sensor.value = 5.3;
            else if(sensor.type === 'wind') sensor.value = 95;
            else sensor.value = 'Perigo';
        }
        
        // Sync river gauge with sensor 2
        if(index === 1){
            simState.riverLevel = sensor.value;
            window.updateRiverGauge(sensor.value);
        }
        
        window.updateSensors();
        updateDevDisplays();
    };
    
    // Update dev panel sensor displays
    function updateDevDisplays(){
        document.getElementById('sensor1Value').textContent = window.sensorData[0].value.toFixed(1) + ' mm/h';
        document.getElementById('sensor2Value').textContent = window.sensorData[1].value.toFixed(1) + ' m';
        document.getElementById('sensor3Value').textContent = window.sensorData[2].value.toFixed(1) + ' km/h';
        document.getElementById('sensor4Value').textContent = window.sensorData[3].value;
    }
    
    // Start simulation on load
    // Inicializar gr√°ficos (Chart.js) ‚Äî se dispon√≠vel
    let rainChart, windChart, riverChart;
    function initCharts(){
        try{
            const ctxR = document.getElementById('chartRain');
            const ctxW = document.getElementById('chartWind');
            const ctxV = document.getElementById('chartRiver');
            console.log('initCharts: elements', !!ctxR, !!ctxW, !!ctxV, 'Chart', typeof Chart);
            if(typeof Chart === 'undefined'){
                console.warn('Chart.js n√£o encontrado. Verifique se o CDN carregou antes de `main.js`.');
                // show small fallback notice in the graphs area if possible
                try{
                    const el = document.getElementById('graficos');
                    if(el && !el.querySelector('.chart-fallback')){
                        const note = document.createElement('div');
                        note.className = 'chart-fallback muted';
                        note.style.marginTop = '8px';
                        note.textContent = 'Gr√°ficos indispon√≠veis: Chart.js n√£o carregado.';
                        el.appendChild(note);
                    }
                }catch(e){}
                return;
            }
            if(!ctxR || !ctxW || !ctxV){
                console.warn('initCharts: canvas elements n√£o encontrados');
                return;
            }

            // Simular loading dos gr√°ficos
            setTimeout(() => {
                document.getElementById('chartRainLoading').style.display = 'none';
                document.getElementById('chartRain').style.display = 'block';
                document.getElementById('chartWindLoading').style.display = 'none';
                document.getElementById('chartWind').style.display = 'block';
                document.getElementById('chartRiverLoading').style.display = 'none';
                document.getElementById('chartRiver').style.display = 'block';
            }, 1500);

            const commonOpts = {
                animation: {
                    duration: 800,
                    easing: 'easeInOutQuart'
                },
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                plugins: { legend: { display: true, position: 'top', labels:{boxWidth:12} }, tooltip: {enabled:true} },
                // hide x-axis labels (show only on hover via tooltip)
                scales: { x: { display: false } }
            };

            // seed history with small jitter to avoid flat initial line
            const now = Date.now();
            const seedCount = window.sensorHistory.maxLen;
            window.sensorHistory.timestamps = [];
            window.sensorHistory.rain = [];
            window.sensorHistory.wind = [];
            window.sensorHistory.river = [];
            for(let i = seedCount - 1; i >= 0; i--){
                const ts = new Date(now - i * 1000);
                window.sensorHistory.timestamps.push(ts.toLocaleTimeString());
                // small jitter
                window.sensorHistory.rain.push(Number((window.sensorData[0].value + (Math.random()-0.5)*3).toFixed(1)));
                window.sensorHistory.wind.push(Number((window.sensorData[2].value + (Math.random()-0.5)*4).toFixed(1)));
                window.sensorHistory.river.push(Number((window.sensorData[1].value + (Math.random()-0.5)*0.05).toFixed(2)));
            }

            rainChart = new Chart(ctxR.getContext('2d'), {
                type: 'line',
                data: { labels: window.sensorHistory.timestamps.slice(), datasets:[{label:'Pluviometria (mm/h)',data: window.sensorHistory.rain.slice(), borderColor:'#60a5fa', backgroundColor:'rgba(96,165,250,0.12)', tension:0.2, pointRadius:2}] },
                options: {...commonOpts, scales:{...commonOpts.scales, y:{min:0, max:100, title:{display:true,text:'mm/h'}}}, layout:{padding:10}}
            });

            windChart = new Chart(ctxW.getContext('2d'), {
                type: 'line',
                data: { labels: window.sensorHistory.timestamps.slice(), datasets:[{label:'Vento (km/h)',data: window.sensorHistory.wind.slice(), borderColor:'#fb923c', backgroundColor:'rgba(251,146,60,0.12)', tension:0.2, pointRadius:2}] },
                options: {...commonOpts, scales:{...commonOpts.scales, y:{min:0, max:100, title:{display:true,text:'km/h'}}}, layout:{padding:10}}
            });

            riverChart = new Chart(ctxV.getContext('2d'), {
                type: 'line',
                data: { labels: window.sensorHistory.timestamps.slice(), datasets:[{label:'N√≠vel do Rio (m)',data: window.sensorHistory.river.slice(), borderColor:'#34d399', backgroundColor:'rgba(52,211,153,0.12)', tension:0.2, pointRadius:2}] },
                options: {...commonOpts, scales:{...commonOpts.scales, y:{min:0, max:10, title:{display:true,text:'m'}}}, layout:{padding:10}}
            });
        }catch(e){ console.warn('Chart init failed', e); }
    }

    function updateCharts(){
        try{
            // push new sample into history (timestamp + values)
            const ts = new Date().toLocaleTimeString();
            const rainVal = Number(window.sensorData[0].value.toFixed(1));
            const windVal = Number(window.sensorData[2].value.toFixed(1));
            const riverVal = Number(window.sensorData[1].value.toFixed(2));

            window.sensorHistory.timestamps.push(ts);
            window.sensorHistory.rain.push(rainVal);
            window.sensorHistory.wind.push(windVal);
            window.sensorHistory.river.push(riverVal);

            // respect selected history length
            try{
                const sel = document.getElementById('historyLen');
                const max = sel ? parseInt(sel.value,10) : window.sensorHistory.maxLen;
                window.sensorHistory.maxLen = max;
            }catch(e){}

            while(window.sensorHistory.timestamps.length > window.sensorHistory.maxLen){ window.sensorHistory.timestamps.shift(); }
            while(window.sensorHistory.rain.length > window.sensorHistory.maxLen){ window.sensorHistory.rain.shift(); }
            while(window.sensorHistory.wind.length > window.sensorHistory.maxLen){ window.sensorHistory.wind.shift(); }
            while(window.sensorHistory.river.length > window.sensorHistory.maxLen){ window.sensorHistory.river.shift(); }

            if(rainChart){ rainChart.data.labels = window.sensorHistory.timestamps.slice(); rainChart.data.datasets[0].data = window.sensorHistory.rain.slice(); rainChart.update('none'); }
            if(windChart){ windChart.data.labels = window.sensorHistory.timestamps.slice(); windChart.data.datasets[0].data = window.sensorHistory.wind.slice(); windChart.update('none'); }
            if(riverChart){ riverChart.data.labels = window.sensorHistory.timestamps.slice(); riverChart.data.datasets[0].data = window.sensorHistory.river.slice(); riverChart.update('none'); }
        }catch(e){/* ignore chart update errors */}
    }

    // Export feature removed per request (button removed from UI).

    // Export button removed from HTML; no wiring necessary.

    // Attempt to initialize charts now and again on load (helps if Chart.js loads slowly)
    try{ initCharts(); }catch(e){ console.warn('initCharts initial call failed', e); }
    window.addEventListener('load', function(){
        try{
            if(typeof Chart !== 'undefined') initCharts();
            else console.warn('Chart.js still undefined on window.load');
        }catch(e){ console.warn('initCharts on load failed', e); }
    });
    startSimulation();
    updateDevStats();
    updateDevDisplays();

    // Periodic dev display update
    setInterval(updateDevDisplays, 2000);
    } // Close initDevPanel function
    
    // Call init function when DOM is ready
    if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', initDevPanel);
    } else {
        // DOM already loaded, call immediately
        setTimeout(initDevPanel, 0);
    }
})();
